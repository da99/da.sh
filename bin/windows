#!/usr/bin/env ruby
#
#
#
cmd = ARGV.map(&:strip).join(' ')
WIN_LOG = "/tmp/windows.txt"

class Window
  attr_reader :win_id, :wm_class, :wm_instance, :title
  attr_accessor :user_time, :position
  def initialize(raw_pieces)
    @win_id, _gravity, class_instance, _host, *titles  = raw_pieces
    @wm_class, @wm_instance = class_instance.split('.')
    @title = titles.join(' ')
    @user_time = 0
    @position = nil
  end
end # class

class Windows
  class << self
    def list
      @list ||= begin
                   `wmctrl -lx`.strip.split("\n").map { |line| 
                     pieces = line.split(/\ +/)
                     if pieces[1] === "-1"
                       nil
                     else
                       Window.new pieces
                     end
                   }.compact
                 end
    end # def

    def list_with_user_time
      list.each { |w|
        w.user_time = `xprop -id #{w.win_id} _NET_WM_USER_TIME`.strip.split.last
      }
      list
    end

    def list_with_position
      positions = `my.kv.ram get-existing #{list.map(&:win_id).join(' ')}`.strip.split("\n").inject({}) { |memo, o|
        win_id, pos = o.split
        memo[win_id] = pos
        memo
      }
      list.each { |w|
        w.position = positions[w.win_id] || w.position
        w
      }
      list
    end

    def active_id
      id = `wmctrl -a :ACTIVE: -v 2>&1`.strip.split.last
      return id if id["0x"]
    end

    def replay
      list_with_position.each { |w|
        next unless w.position
        move(w.win_id, w.position)
      }
    end # def

    def direction_to_object(str)
      case str
      when "right_top"
        Right_Top

      when "right_bottom"
        Right_Bottom

      when "maximize"
        Maximized

      when "right"
        Right

      when "left"
        Left
      else
        raise "Unknown direction: #{str.inspect}"
      end
    end

    def move(active_id, direction)
      d = direction_to_object(direction)
      cmd = "wmctrl #{active_id.index('0x') == 0 ? '-i' : ''} -r #{active_id} -e 0,#{d.x},#{d.y},#{d.w},#{d.h}"
      puts cmd
      `#{cmd}`
    end
  end # class self
end # class

class Geo
  class << self

    def _init
      if not defined? @raw_area
        @raw_area = `xprop -notype -len 16 -root _NET_DESKTOP_GEOMETRY`.split('=').last.split(',').map(&:strip).map(&:to_i)
        @screen_w, @screen_h = @raw_area
      end
      @raw_area
    end

    def current_name
      case "#{w} #{h}"
      when "2560 1440"
        "2k"
      when "1920 1080"
        "1080p"
      when "3840 2160"
        "4k"
      else
        raise "Unknown resolution: #{w} #{h}"
      end
    end # def

    def w
      _init
      @screen_w
    end

    def h
      _init
      @screen_h
    end

  end # class self
end # class

class Margin
  class << self
    def padding
      15
    end

    def top
      40
    end

    def left
      55
    end

    def bottom
      20
    end

    def right
      20
    end
  end # class
end # class

class Maximized
  class << self

    def x
      Margin.left
    end

    def y
      Margin.top
    end

    def w
      (Geo.w - Margin.left - Margin.right).to_i
    end

    def h
      Left.h
    end
  end # class self
end # class

class Left
  class << self

    def x
      Margin.left
    end

    def y
      Margin.top
    end

    def w
      ((Geo.w - Margin.left - Margin.right) * 0.60).to_i - Margin.padding
    end

    def h
      (Geo.h - Margin.top - Margin.bottom) - Margin.padding
    end
  end # class self
end # class

class Right
  class << self
    def x
      Left.x + Left.w + Margin.padding
    end

    def y
      Left.y
    end

    def w
      Geo.w - x - Margin.right
    end

    def h
      Left.h + Margin.bottom
    end
  end # class
end # class

class Right_Top
  class << self
    def x
      Left.x + Left.w + Margin.padding
    end

    def y
      Left.y
    end

    def w
      Geo.w - x - Margin.right
    end

    def h
      (Left.h / 2).to_i - (Margin.padding * 4)
    end
  end # class
end # class

class Right_Bottom
  class << self
    def x
      Right_Top.x
    end

    def y
      Right_Top.y + Right_Top.h + (Margin.padding * 1)
    end

    def w
      Right_Top.w
    end

    def h
      Geo.h - y - Margin.padding
    end
  end # class
end # class

case cmd
when "help", "-h", "--help"
  puts "  list"
  puts "  list class [class]"
  puts "  list ids"
  puts "  list count"
  puts "  list is empty"
  puts "  active id"
  puts "  screen geo name"
  puts "  move [id | :ACTIVE:] [right | right_top | right_bottom | left | maximize]"
  puts "  maximize"
  puts "  next [up|down|left|right] [id | :ACTIVE:]"

when "active id"
  puts Windows.active_id

when "screen geo name"
  puts Geo.current_name

when "list"
  Windows.list_with_user_time
  Windows.list_with_position
  Windows.list.each { |l|
    puts "#{l.win_id} #{l.wm_class} #{l.user_time} #{l.position || "unknown"} #{l.title}"
  }

when /^list class .+/
  target = ARGV[2]
  Windows.list.each { |w|
    if w.wm_class == target
      puts w.win_id
    end
  }
when "list ids"
  Windows.list.each { |w| puts w.win_id }

when "list count"
  id = Windows.list.size
  if id
    puts id
  else
    exit 1
  end

when "list is empty"
  if Windows.list.empty?
    exit 0
  else
    exit 1
  end

when /^move .+/
  Windows.move(ARGV[1], ARGV[2])

when /^next (up|down|left|right)/
  dir = ARGV[1]
  win_id = ARGV[2] || Windows.active_id
  Windows.list_with_user_time
  Windows.list_with_position
  current = Windows.list.detect { |w| w.win_id == win_id } ||
    Windows.list.detect { |w| w.position == "left" } 
  unless current
    STDERR.puts "No current window found: #{dir} #{win_id}"
    exit 0 
  end

  next_position = case "#{current.position} #{dir}"
                  when "right_top left", "right_bottom left"
                    "left"
                  when "right left"
                    "left"
                  when "left right"
                    "right_top"
                  when "right_bottom up"
                    "right_top"
                  when "right_top down"
                    "right_bottom"
                  else
                    STDERR.puts "No window in desired direction: #{dir} from #{current.position}"
                    exit 0
                  end

  new_win = Windows.list.sort_by(&:user_time).reverse.detect { |w| w.position == next_position }
  unless new_win
    STDERR.puts "No new window found: #{dir} #{win_id} -> #{next_position}"
    exit(0) 
  end

  cmd = "wmctrl -i -a #{new_win.win_id}"
  puts cmd
  `#{cmd}`


when "replay"
  Windows.replay

else
  STDERR.puts "!!! Unknown option: #{cmd}"
  exit 1
end # cae

