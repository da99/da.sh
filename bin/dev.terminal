#!/usr/bin/env ruby
#
#


require "open3"

USR1 = "/tmp/usr1.sh"
USR2 = "/tmp/usr2.sh"
cmd = USR1
pid = false
keep_running = true
already_run = false
STDERR.puts "#{$PROGRAM_NAME} pid #{Process.pid}"

Signal.trap("INT") { keep_running = false; Process.kill("INT", pid) if pid }
Signal.trap("TERM") { keep_running = false; Process.kill("INT", pid) if pid }
Signal.trap("USR1") { already_run = false; cmd = USR1 }
Signal.trap("USR2") { already_run = false; cmd = USR2 }


2.times do |i|
  if !File.exists?("/tmp/usr#{i + 1}.sh")
    `da.sh new zsh /tmp/usr#{i + 1}.sh`
  end
end

STDERR.puts cmd.inspect

class Colorize
  class << self
    # colorization
    def colorize(color_code, str)
      "\e[#{color_code}m#{str}\e[0m"
    end

    def red(str)
      colorize(31, str)
    end

    def green(str)
      colorize(32, str)
    end

    def yellow(str)
      colorize(33, str)
    end

    def blue(str)
      colorize(34, str)
    end

    def pink(str)
      colorize(35, str)
    end

    def light_blue(str)
      colorize(36, str)
    end
  end # class
end

while keep_running
  if already_run
    sleep 0.5
    next
  end
  puts ""
  puts "------------------------------------------------------"
  already_run = true
  Open3.popen3(cmd) do |i, o, e, stat|
    puts "#{cmd} PID: #{stat.pid}"
    pid = stat.pid
    Thread.new {
      e.each_line { |line|
        STDERR.puts Colorize.yellow(line.strip)
      }
    }
    Thread.new {
      o.each_line { |line|
        STDOUT.puts line.strip
      }
    }
    puts "ended: #{cmd}: #{stat.value.success?.inspect} #{Time.now}"
  end
  pid = nil
end # while

puts "Done: #{$PROGRAM_NAME} #{cmd.inspect} #{Time.now}"

