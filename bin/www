#!/usr/bin/env ruby
# frozen_string_literal: true

require 'json'

cmd = ARGV.join(' ')
prog = __FILE__.split('/').last

# Uses templates/ dir.
class Template
  DIR = File.join File.dirname(File.dirname(__FILE__)), 'templates'
  class << self
    def compile(name, pairs)
      template_content = File.read(File.join(Template::DIR, name))
      pairs.each_pair do |k, v|
        template_content = template_content.gsub("$#{k}", v)
      end
      template_content
    end
  end # class << self
end # class Template

# Represents a file in the public directory.
class PublicFile
  class << self
    def all(raw_dir)
      dir = normalize_dir(raw_dir)
      PublicFile.dir_exist!(dir)
      `find #{dir} -type f | xargs sha256sum`
        .strip
        .split("\n")
        .map { |l| PublicFile.new(dir, l) }
    end # def

    def normalize_dir(raw)
      raw.sub(%r{^\.?/}, '')
    end

    def dir_exist!(raw)
      dir = normalize_dir(raw)
      unless Dir.exist?(dir)
        warn "!!! Directory not found: #{dir}"
        exit 1
      end
      dir
    end

    def manifest(raw_dir)
      dir = normalize_dir(raw_dir)
      all(dir).inject({}) do |memo, new_file|
        memo[new_file.path.sub(dir, '')] = { 'public_path' => new_file.public_path, 'etag' => new_file.etag[0..8] }
        memo
      end
    end

    def write_manifest(raw_dir)
      json = manifest(raw_dir).to_json
      File.write 'files.mjs', Template.compile('file.mjs', { 'JSON' => json })
      puts '=== Wrote: files.mjs'
      File.write('files.json', json)
      puts '=== Wrote: files.json'
    end
  end # class << self

  attr_reader :dir, :raw, :etag, :path

  def initialize(dir, raw)
    @raw = raw
    @dir = PublicFile.normalize_dir(dir)
    pieces = raw.split
    @etag = pieces.shift
    if pieces.size != 1
      warn "!!! Invalid file path: #{path.join(' ')}"
      exit 2
    end
    @path = pieces.shift
  end # def

  def public_path
    pieces = path.split('.')
    pieces[pieces.size - 1] = "#{etag[0..5]}.#{pieces.last}"
    pieces.join('.').sub(dir, '')
  end

  def summary
    Hash.new(
      'path' => path,
      'dir' => dir,
      'public_path' => public_path,
      'etag' => etag
    )
  end # def
end # class

# Manage a files for a Bucket.
class Bucket
  class << self
    def file_json
      'bucket_files.json'
    end
  end # class << self

  attr_reader :dir, :files, :bucket

  def initialize(raw_dir, bucket)
    @bucket = bucket
    @dir = PublicFile.normalize_dir(raw_dir)

    `touch "#{self.class.file_json}"`
    txt = File.read(self.class.file_json).strip
    @files = txt.empty? ? [] : JSON.parse(txt)
  end # def

  def upload_file(new_file)
    cmd = %( bunx wrangler r2 object put "#{File.join(bucket, new_file.public_path)}" --file="#{new_file.path}" )
    puts "\n--- Uploading: #{cmd}"
    exit(1) unless system(cmd)
    new_file.summary
  end

  def upload
    old_etags = files.map { |x| x['etag'] }

    summarys = PublicFile.all(dir).map do |new_file|
      upload_file(new_file) unless old_etags.include?(new_file.etag)
    end

    return false if summarys.empty?

    @files.concat(summarys)
    puts "=== Finished uploading. Saving to: #{self.class.file_json}"
    File.write(self.class.file_json, @files.to_json)
  end # def
end # class

case cmd
when '-h', '--help', 'help'
  puts "#{prog} -h|--help|help  --  Show this message."
  puts "#{prog} upload public [dir] to [bucket]"
  puts "#{prog} write file manifest for [dir]"
  puts "#{prog} set src to [domain]"
  puts "#{prog} info"

when 'info'
  puts "__FILE__ :     #{__FILE__}"
  puts "file dir:      #{File.dirname __FILE__}"
  puts "templates dir: #{Template::DIR}"
  puts "dir:       #{Dir.pwd}"
  puts "prog:      #{prog}"

when %r{^upload public ([./0-9A-Z]+) to (\w+)$}i
  `touch bucket_files.json`
  dir = Regexp.last_match(1)
  domain = Regexp.last_match(2)
  b = Bucket.new(dir, domain)
  b.upload

when %r{^write file manifest for ([./0-9A-Z]+)$}i
  PublicFile.write_manifest(Regexp.last_match(1))

when /^set src to (.+)$/i
  dir = 'dist'
  domain = Regexp.last_match(1)
  manifest = PublicFile.manifest(dir)
  files = `find "#{dir}" -type f -name '*.html'`.strip.split('\n')
  if files.empty?
    puts "--- No files found for: setting #{dir}"
  else
    puts "--- Setting #{dir} to https://#{domain}..."
  end
  files.each do |raw|
    origin = File.read(raw)
    new_body = origin.gsub(/(src|href)="([^"]+)"/) do |match|
      attr = Regexp.last_match(1)
      new_val = manifest[Regexp.last_match(2)]
      if new_val
        %(#{attr}="https://#{File.join domain, new_val['public_path']}")
      else
        match
      end
    end # .gsub
    if origin == new_body
      warn "--- Skipping: #{raw}"
      next
    end
    warn "=== Updated: #{raw}"
    File.write(raw, new_body)
  end # files.each

else
  warn "!!! Unknown command: #{cmd}"
  exit 1
end # case
