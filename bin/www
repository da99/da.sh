#!/usr/bin/env ruby
# frozen_string_literal: true

require 'json'

cmd = ARGV.join(' ')
prog = __FILE__.split('/').last

class Public_File
  class << self
    def all(raw_dir)
      dir = normalize_dir(raw_dir)
      Public_File.dir_exist!(dir)
      `find #{dir} -type f | xargs sha256sum`
        .strip
        .split("\n")
        .map { |l| Public_File.new(dir, l) }
    end # def

    def normalize_dir(raw)
      raw.sub(%r{^\.?/}, '')
    end

    def dir_exist!(raw)
      dir = normalize_dir(raw)
      unless Dir.exist?(dir)
        warn "!!! Directory not found: #{dir}"
        exit 1
      end
      dir
    end

    def manifest(raw_dir)
      dir = normalize_dir(raw_dir)
      all(dir).inject({}) do |memo, f|
        memo[f.path.sub(dir, '')] = { 'public_path' => f.public_path, 'etag' => f.etag[0..8] }
        memo
      end
    end

    def write_manifest(raw_dir)
      json = manifest(raw_dir).to_json
      File.write('files.mjs', %(const a = #{json} ;\nexport default a;\n))
      puts '=== Wrote: files.mjs'
      File.write('files.json', json)
      puts '=== Wrote: files.json'
    end
  end # class << self

  attr_reader :dir, :raw, :etag, :path

  def initialize(dir, raw)
    @raw = raw
    @dir = Public_File.normalize_dir(dir)
    pieces = raw.split
    @etag = pieces.shift
    if pieces.size != 1
      warn "!!! Invalid file path: #{path.join(' ')}"
      exit 2
    end
    @path = pieces.shift
  end # def

  def public_path
    pieces = path.split('.')
    pieces[pieces.size - 1] = "#{etag[0..5]}.#{pieces.last}"
    pieces.join('.').sub(dir, "")
  end

  def summary
    {"path"=>path, dir => dir, "public_path"=>public_path, "etag"=> etag}
  end # def
end # class

class Bucket

  class << self
    def file_json
      "bucket_files.json"
    end
  end # class << self

  attr_reader :dir, :files, :bucket

  def initialize(raw_dir, bucket)
    @bucket = bucket
    @dir = Public_File.normalize_dir(raw_dir)
    @files = begin
               `touch "#{self.class.file_json}"`
               txt = File.read(self.class.file_json).strip
               if txt.empty?
                 []
               else
                 JSON.parse(txt)
               end
             end
  end # def

  def upload
    old_etag = files.map { |x| x["etag"] }

    new_files = Public_File.all(dir).reject { |f| old_etag.include?(f.etag)}
    summarys = Public_File.all.map { |f|
        cmd = %[bunx wrangler r2 object put #{File.join(bucket, f.public_path)} --file="#{f.path}"]
        # puts "--- Uploading: #{f.path}"
        puts ""
        puts "--- #{cmd}"
        success = system(cmd)
        exit(1) unless success
        f.summary
    }
    if summarys.empty?
      puts "=== No new files to upload. ==="
      return false
    end
    @files = @files.concat(summarys)
    puts "=== Finished uploading."
    puts "=== Saving to: #{self.class.file_json}"
    File.write(self.class.file_json, @files.to_json)
    true
  end # def
end # class

case cmd
when '-h', '--help', 'help'
  puts "#{prog} -h|--help|help  --  Show this message."
  puts "#{prog} upload public [dir] to [bucket]"
  puts "#{prog} write file manifest for [dir]"
  puts "#{prog} set src to [domain]"

when %r{^upload public ([./0-9A-Z]+) to (\w+)$}i
  `touch bucket_files.json`
  dir = Regexp.last_match(1)
  domain = Regexp.last_match(2)
  b = Bucket.new(dir, domain)
  b.upload

when %r{^write file manifest for ([./0-9A-Z]+)$}i
  Public_File.write_manifest(Regexp.last_match(1))

when /^set src to (.+)$/i
  dir = 'dist'
  domain = Regexp.last_match(1)
  manifest = Public_File.manifest(dir)
  files = `find "#{dir}" -type f -name '*.html'`.strip.split('\n')
  if files.empty?
    puts "--- No files found for: setting #{dir}"
  else
    puts "--- Setting #{dir} to https://#{domain}..."
  end
  files.each do |raw|
    origin = File.read(raw)
    new_body = origin.gsub(/(src|href)="([^"]+)"/) do |match|
      attr = Regexp.last_match(1)
      new_val = manifest[Regexp.last_match(2)]
      if new_val
        %(#{attr}="https://#{File.join domain, new_val['public_path']}")
      else
        match
      end
    end # .gsub
    if origin == new_body
      warn "--- Skipping: #{raw}"
      next
    end
    warn "=== Updated: #{raw}"
    File.write(raw, new_body)
  end # files.each

else
  warn "!!! Unknown command: #{cmd}"
  exit 1
end # case
